<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML to Table & CSV Converter</title>
    <style>
        /* Previous styles remain the same */
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            background-color: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .upload-area {
            border: 2px dashed #ccc;
            padding: 20px;
            text-align: center;
            margin: 20px 0;
            border-radius: 4px;
        }
        .upload-area.dragover {
            background-color: #e1f5fe;
            border-color: #2196f3;
        }
        button {
            background-color: #2196f3;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 0;
        }
        #status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
        }
        .success { background-color: #e8f5e9; color: #2e7d32; }
        .error { background-color: #ffebee; color: #c62828; }
        .csv-output {
            margin-top: 20px;
            padding: 10px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            white-space: pre-wrap;
            font-family: monospace;
            max-height: 300px;
            overflow-y: auto;
        }
        .copy-button {
            background-color: #4caf50;
            margin-top: 10px;
        }
        .tab-buttons button.active {
            background-color: #1976d2;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>XML to CSV Converter</h1>
        <p>Upload your XML file to convert it to CSV format.</p>
        
        <div class="upload-area" id="dropZone">
            <p>Drop your XML file here or click to select</p>
            <input type="file" id="fileInput" accept=".xml" style="display: none">
            <button onclick="document.getElementById('fileInput').click()">Select File</button>
        </div>

        <div id="status"></div>
        <div id="summary" class="summary" style="display: none;"></div>

        <div id="csvView">
            <div class="csv-output" id="csvOutput"></div>
            <button onclick="copyToClipboard()" class="copy-button">Copy CSV to Clipboard</button>
        </div>
    </div>

    <script>
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const status = document.getElementById('status');
        const summaryDiv = document.getElementById('summary');
        const csvOutput = document.getElementById('csvOutput');

        // Event Listeners
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file.type === 'text/xml' || file.name.endsWith('.xml')) {
                processFile(file);
            } else {
                showStatus('Please upload an XML file.', 'error');
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                processFile(file);
            }
        });

        function processFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(e.target.result, 'text/xml');
                    
                    if (doc.querySelector('parsererror')) {
                        throw new Error('XML parsing failed');
                    }

                    const data = processXML(doc);
                    if (data.length === 0) {
                        throw new Error('No valid entries found in XML');
                    }
                    
                    displayResults(data);
                    showStatus('File processed successfully!', 'success');
                } catch (error) {
                    showStatus('Error processing file: ' + error.message, 'error');
                    csvOutput.textContent = '';
                    summaryDiv.style.display = 'none';
                }
            };
            reader.readAsText(file);
        }

        function processXML(doc) {
            const data = [];
            const namespace = 'urn:iso:std:iso:20022:tech:xsd:camt.053.001.02';
            
            function nsResolver(prefix) {
                return prefix === 'bs' ? namespace : null;
            }

            try {
                const stmts = doc.evaluate("//bs:Stmt", doc, nsResolver, XPathResult.ANY_TYPE, null);
                let stmt;

                while (stmt = stmts.iterateNext()) {
                    const typeNode = doc.evaluate(".//bs:Bal/bs:Tp/bs:CdOrPrtry/bs:Prtry", stmt, nsResolver, 
                        XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
                    const statementType = typeNode?.textContent;

                    if (['Incoming (Rejected)', 'Outgoing (Rejected)'].includes(statementType)) {
                        continue;
                    }

                    const entries = doc.evaluate(".//bs:Ntry", stmt, nsResolver, XPathResult.ANY_TYPE, null);
                    let entry;

                    while (entry = entries.iterateNext()) {
                        const bookingDate = doc.evaluate("bs:BookgDt/bs:DtTm", entry, nsResolver,
                            XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue?.textContent;

                        let amount = parseFloat(doc.evaluate("bs:Amt", entry, nsResolver,
                            XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue?.textContent || '0');

                        if (statementType === 'Outgoing (Accepted)') {
                            amount *= -1;
                        }

                        const messageId = doc.evaluate(".//bs:Refs/bs:MsgId", entry, nsResolver,
                            XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue?.textContent || '';

                        const instructionId = doc.evaluate(".//bs:Refs/bs:InstrId", entry, nsResolver,
                            XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue?.textContent || '';

                        if (bookingDate) {
                            data.push([bookingDate, messageId, instructionId, amount]);
                        }
                    }
                }

                data.sort((a, b) => new Date(a[0]) - new Date(b[0]));

                let runningBalance = 0;
                data.forEach(row => {
                    runningBalance += row[3];
                    row.push(runningBalance);
                });

                return data;

            } catch (error) {
                console.error('Error processing XML:', error);
                throw error;
            }
        }

        function displayResults(data) {
            // Calculate summary statistics
            let totalPositive = 0;
            let totalNegative = 0;
            let finalBalance = 0;

            data.forEach(row => {
                const amount = parseFloat(row[3]);
                if (amount > 0) totalPositive += amount;
                if (amount < 0) totalNegative += Math.abs(amount);
                finalBalance = parseFloat(row[4]);
            });

            // Display summary
            summaryDiv.innerHTML = `
                <strong>Summary:</strong><br>
                Total Entries: ${data.length}<br>
                Total Incoming: ${totalPositive.toFixed(2)}<br>
                Total Outgoing: ${totalNegative.toFixed(2)}<br>
                Final Balance: ${finalBalance.toFixed(2)}
            `;

            // Generate and display CSV
            const csvContent = generateCSV(data);
            csvOutput.textContent = csvContent;

            summaryDiv.style.display = 'block';
        }

        function generateCSV(data) {
            const header = ['Booking Date', 'Message ID', 'Instruction ID', 'Amount', 'Running Balance'];
            const rows = [header];
            
            data.forEach(row => {
                const date = new Date(row[0]);
                const formattedDate = date.toLocaleString();
                rows.push([
                    formattedDate,
                    row[1],
                    row[2],
                    row[3].toFixed(2),
                    row[4].toFixed(2)
                ]);
            });

            return rows.map(row => 
                row.map(cell => {
                    if (cell === null || cell === undefined) return '';
                    const str = cell.toString();
                    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                        return `"${str.replace(/"/g, '""')}"`;
                    }
                    return str;
                }).join(',')
            ).join('\n');
        }

        function copyToClipboard() {
            const textArea = document.createElement('textarea');
            textArea.value = csvOutput.textContent;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            
            const copyBtn = document.querySelector('.copy-button');
            const originalText = copyBtn.textContent;
            copyBtn.textContent = 'Copied!';
            setTimeout(() => {
                copyBtn.textContent = originalText;
            }, 2000);
        }

        function showStatus(message, type) {
            status.textContent = message;
            status.className = type;
            console.log(`Status (${type}):`, message);
        }
    </script>
</body>
</html>